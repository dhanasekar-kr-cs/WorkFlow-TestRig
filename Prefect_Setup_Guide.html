<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Prefect Workflow Orchestration Setup</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            max-width: 800px;
            margin: 0 auto;
            background: white;
            padding: 40px;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(0,0,0,0.1);
        }
        h1 {
            color: #2c3e50;
            border-bottom: 3px solid #3498db;
            padding-bottom: 10px;
        }
        h2 {
            color: #34495e;
            margin-top: 30px;
            border-left: 4px solid #3498db;
            padding-left: 15px;
        }
        h3 {
            color: #2c3e50;
            margin-top: 25px;
        }
        .emoji {
            font-size: 1.2em;
        }
        code {
            background-color: #f8f9fa;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            color: #e74c3c;
        }
        pre {
            background-color: #2c3e50;
            color: #ecf0f1;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
        }
        pre code {
            background: none;
            color: inherit;
            padding: 0;
        }
        .highlight {
            background-color: #fff3cd;
            padding: 15px;
            border-left: 4px solid #ffc107;
            margin: 15px 0;
        }
        .success {
            background-color: #d4edda;
            padding: 15px;
            border-left: 4px solid #28a745;
            margin: 15px 0;
        }
        .warning {
            background-color: #f8d7da;
            padding: 15px;
            border-left: 4px solid #dc3545;
            margin: 15px 0;
        }
        ul, ol {
            margin: 15px 0;
            padding-left: 30px;
        }
        li {
            margin: 8px 0;
        }
        .toc {
            background-color: #f8f9fa;
            padding: 20px;
            border-radius: 5px;
            margin: 20px 0;
        }
        .toc h3 {
            margin-top: 0;
            color: #495057;
        }
        .toc ul {
            list-style-type: none;
            padding-left: 0;
        }
        .toc li {
            margin: 5px 0;
        }
        .toc a {
            text-decoration: none;
            color: #007bff;
        }
        .toc a:hover {
            text-decoration: underline;
        }
        .footer {
            margin-top: 40px;
            padding-top: 20px;
            border-top: 2px solid #dee2e6;
            text-align: center;
            color: #6c757d;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1><span class="emoji">🚀</span> Prefect Workflow Orchestration Setup</h1>
        
        <div class="toc">
            <h3>Table of Contents</h3>
            <ul>
                <li><a href="#overview">🎯 Overview</a></li>
                <li><a href="#structure">📁 Repository Structure</a></li>
                <li><a href="#quickstart">🚀 Quick Start</a></li>
                <li><a href="#configuration">🔧 Configuration</a></li>
                <li><a href="#auto-deploy">🔄 Automatic Deployment System</a></li>
                <li><a href="#flows">📊 Available Flows</a></li>
                <li><a href="#ui-usage">🌐 Prefect UI Usage</a></li>
                <li><a href="#monitoring">🔍 Monitoring and Troubleshooting</a></li>
                <li><a href="#security">🔐 Security Best Practices</a></li>
                <li><a href="#production">📈 Scaling and Production</a></li>
                <li><a href="#development">🛠️ Development Workflow</a></li>
                <li><a href="#auto-deploy-script">🤖 Auto-Deploy Script Details</a></li>
                <li><a href="#prefect-yaml">⚙️ Prefect Configuration</a></li>
                <li><a href="#requirements">📦 Dependencies</a></li>
                <li><a href="#flow-examples">💻 Complete Flow Examples</a></li>
            </ul>
        </div>

        <h2 id="overview"><span class="emoji">🎯</span> Overview</h2>
        <p>This repository contains a complete Prefect workflow orchestration system with automatic deployment capabilities. The system automatically discovers and deploys Prefect flows from Python files, syncs with GitHub changes every 2 minutes, and provides a web UI for monitoring and execution.</p>

        <h2 id="structure"><span class="emoji">📁</span> Repository Structure</h2>
        <pre><code>WorkFlow-TestRig/
├── CloudFlare_Stats_To_Slack_Prefect.py    # CloudFlare stats to Slack flow
├── zstd_to_csv_converter_prefect.py        # ZSTD file converter flow
├── auto_deploy_flows.py                    # Automatic deployment script
├── check_auto_deploy.py                    # Deployment monitoring script
├── prefect.yaml                           # Prefect configuration
├── requirement.txt                         # Python dependencies
└── README.md                               # This file</code></pre>

        <h2 id="quickstart"><span class="emoji">🚀</span> Quick Start</h2>
        
        <h3>Prerequisites</h3>
        <ul>
            <li>Python 3.12+</li>
            <li>Prefect 3.x</li>
            <li>Ubuntu/Linux environment</li>
            <li>GitHub repository with workflow files</li>
        </ul>

        <h3>Installation</h3>
        <ol>
            <li><strong>Clone the repository:</strong>
                <pre><code>git clone &lt;your-github-repo&gt;
cd WorkFlow-TestRig</code></pre>
            </li>
            <li><strong>Create virtual environment:</strong>
                <pre><code>python -m venv .venv/prefect
source .venv/prefect/bin/activate</code></pre>
            </li>
            <li><strong>Install dependencies:</strong>
                <pre><code>pip install -r requirement.txt</code></pre>
            </li>
            <li><strong>Start Prefect server:</strong>
                <pre><code>prefect server start --host 0.0.0.0</code></pre>
            </li>
            <li><strong>Create work pool:</strong>
                <ul>
                    <li>Go to Prefect UI: <code>http://your-server:4200</code></li>
                    <li>Navigate to "Work Pools"</li>
                    <li>Create a new work pool named <code>default-pool</code></li>
                </ul>
            </li>
            <li><strong>Start worker:</strong>
                <pre><code>prefect worker start --pool default-pool</code></pre>
            </li>
        </ol>

        <h2 id="configuration"><span class="emoji">🔧</span> Configuration</h2>
        
        <h3>Environment Variables</h3>
        <p>The system uses Prefect Secret blocks for secure token management:</p>
        
        <div class="highlight">
            <strong>Create Secret Blocks in Prefect UI:</strong>
            <ol>
                <li>Go to "Blocks" → "+" → "Secret"</li>
                <li>Create <code>cloudflare-api-token</code> with your CloudFlare API token</li>
                <li>Create <code>slack-bot-token</code> with your Slack bot token</li>
            </ol>
        </div>

        <h3>File Paths</h3>
        <ul>
            <li><strong>Input ZSTD file:</strong> <code>/home/ubuntu/Files/Input.zstd</code></li>
            <li><strong>Output CSV files:</strong> <code>/home/ubuntu/Output files/</code></li>
            <li><strong>Log files:</strong> <code>/home/ubuntu/auto_deploy.log</code></li>
        </ul>

        <h2 id="auto-deploy"><span class="emoji">🔄</span> Automatic Deployment System</h2>
        
        <h3>How It Works</h3>
        <p>The system automatically:</p>
        <ol>
            <li><strong>Scans</strong> the WorkFlow-TestRig directory every 2 minutes</li>
            <li><strong>Discovers</strong> all Python files with Prefect flows</li>
            <li><strong>Creates/Updates</strong> deployments automatically</li>
            <li><strong>Syncs</strong> with GitHub changes</li>
            <li><strong>Logs</strong> all activities</li>
        </ol>

        <h3>Setup Automatic Deployment</h3>
        <ol>
            <li><strong>Run the auto-deploy script:</strong>
                <pre><code>python auto_deploy_flows.py</code></pre>
            </li>
            <li><strong>Set up cron job:</strong>
                <pre><code># Add to crontab
*/2 * * * * cd /home/ubuntu/WorkFlow-TestRig && source /home/ubuntu/.venv/prefect/bin/activate && python auto_deploy_flows.py >> /home/ubuntu/auto_deploy.log 2>&1</code></pre>
            </li>
            <li><strong>Monitor deployment status:</strong>
                <pre><code>python check_auto_deploy.py</code></pre>
            </li>
        </ol>

        <h2 id="flows"><span class="emoji">📊</span> Available Flows</h2>
        
        <h3>1. CloudFlare Stats to Slack Flow</h3>
        <p><strong>File:</strong> <code>CloudFlare_Stats_To_Slack_Prefect.py</code></p>
        <p><strong>Purpose:</strong> Fetches CloudFlare statistics and sends formatted reports to Slack</p>
        
        <div class="success">
            <strong>Features:</strong>
            <ul>
                <li>Fetches yesterday's CloudFlare metrics</li>
                <li>Calculates hit ratio, cache coverage, bandwidth</li>
                <li>Sends color-coded Slack messages</li>
                <li>Uses Prefect Secret blocks for secure token storage</li>
            </ul>
            <p><strong>Deployment Name:</strong> <code>cloudflare-stats-flow</code></p>
        </div>

        <h3>2. ZSTD to CSV Converter Flow</h3>
        <p><strong>File:</strong> <code>zstd_to_csv_converter_prefect.py</code></p>
        <p><strong>Purpose:</strong> Converts ZSTD compressed files to CSV format</p>
        
        <div class="success">
            <strong>Features:</strong>
            <ul>
                <li>Decompresses ZSTD files to JSON</li>
                <li>Converts JSON to multiple CSV files</li>
                <li>Splits large datasets (1M rows per file)</li>
                <li>Detailed progress logging</li>
                <li>Automatic cleanup of temporary files</li>
            </ul>
            <p><strong>Deployment Name:</strong> <code>zstd-to-csv-converter-flow</code></p>
        </div>

        <h2 id="ui-usage"><span class="emoji">🌐</span> Prefect UI Usage</h2>
        
        <h3>Accessing the UI</h3>
        <p><strong>URL:</strong> <code>http://your-server:4200</code></p>

        <h3>Key Features</h3>
        <ol>
            <li><strong>Deployments Tab:</strong>
                <ul>
                    <li>View all available deployments</li>
                    <li>Run deployments manually</li>
                    <li>Monitor deployment status</li>
                </ul>
            </li>
            <li><strong>Runs Tab:</strong>
                <ul>
                    <li>View execution history</li>
                    <li>Check detailed logs</li>
                    <li>Monitor flow run status</li>
                </ul>
            </li>
            <li><strong>Work Pools Tab:</strong>
                <ul>
                    <li>Manage work pools</li>
                    <li>Monitor worker status</li>
                    <li>Configure worker settings</li>
                </ul>
            </li>
            <li><strong>Blocks Tab:</strong>
                <ul>
                    <li>Manage Secret blocks</li>
                    <li>Store API tokens securely</li>
                    <li>Configure external integrations</li>
                </ul>
            </li>
        </ol>

        <h3>Running Flows</h3>
        <ol>
            <li><strong>Navigate to Deployments</strong></li>
            <li><strong>Find your deployment</strong> (e.g., <code>cloudflare-stats-flow</code>)</li>
            <li><strong>Click "Run"</strong> button</li>
            <li><strong>Monitor execution</strong> in the Runs tab</li>
        </ol>

        <h2 id="monitoring"><span class="emoji">🔍</span> Monitoring and Troubleshooting</h2>
        
        <h3>Log Files</h3>
        <ul>
            <li><strong>Auto-deploy logs:</strong> <code>/home/ubuntu/auto_deploy.log</code></li>
            <li><strong>Worker logs:</strong> Check worker process output</li>
            <li><strong>Prefect server logs:</strong> Check server process output</li>
        </ul>

        <h3>Common Commands</h3>
        <pre><code># Check auto-deploy status
python check_auto_deploy.py

# View live deployment logs
tail -f /home/ubuntu/auto_deploy.log

# Check Prefect server status
curl http://localhost:4200/api/health

# List current deployments
prefect deployment ls

# Check worker status
ps aux | grep prefect</code></pre>

        <h3>Troubleshooting</h3>
        <ol>
            <li><strong>Deployments not showing in UI:</strong>
                <ul>
                    <li>Check if auto-deploy script is running</li>
                    <li>Verify cron job is active: <code>crontab -l</code></li>
                    <li>Check deployment logs</li>
                </ul>
            </li>
            <li><strong>Workers not connecting:</strong>
                <ul>
                    <li>Ensure work pool exists</li>
                    <li>Check worker configuration</li>
                    <li>Verify Prefect server is accessible</li>
                </ul>
            </li>
            <li><strong>Flows failing to run:</strong>
                <ul>
                    <li>Check Secret blocks are configured</li>
                    <li>Verify file paths exist</li>
                    <li>Review flow run logs in UI</li>
                </ul>
            </li>
        </ol>

        <h2 id="security"><span class="emoji">🔐</span> Security Best Practices</h2>
        
        <h3>Token Management</h3>
        <div class="success">
            <ul>
                <li>✅ <strong>Use Prefect Secret blocks</strong> for API tokens</li>
                <li>✅ <strong>Never hardcode</strong> sensitive information</li>
                <li>✅ <strong>Rotate tokens</strong> regularly</li>
                <li>✅ <strong>Use environment-specific</strong> configurations</li>
            </ul>
        </div>

        <h3>Access Control</h3>
        <div class="success">
            <ul>
                <li>✅ <strong>Restrict UI access</strong> to authorized users</li>
                <li>✅ <strong>Use HTTPS</strong> in production</li>
                <li>✅ <strong>Monitor access logs</strong></li>
                <li>✅ <strong>Implement proper authentication</strong></li>
            </ul>
        </div>

        <h2 id="production"><span class="emoji">📈</span> Scaling and Production</h2>
        
        <h3>Production Considerations</h3>
        <ol>
            <li><strong>Database Backend:</strong>
                <ul>
                    <li>Use PostgreSQL instead of SQLite</li>
                    <li>Configure proper connection pooling</li>
                </ul>
            </li>
            <li><strong>Worker Scaling:</strong>
                <ul>
                    <li>Deploy multiple workers</li>
                    <li>Use different work pools for different workloads</li>
                    <li>Implement worker auto-scaling</li>
                </ul>
            </li>
            <li><strong>Monitoring:</strong>
                <ul>
                    <li>Set up proper logging</li>
                    <li>Implement health checks</li>
                    <li>Use monitoring tools (Prometheus, Grafana)</li>
                </ul>
            </li>
            <li><strong>High Availability:</strong>
                <ul>
                    <li>Deploy multiple Prefect servers</li>
                    <li>Use load balancers</li>
                    <li>Implement failover mechanisms</li>
                </ul>
            </li>
        </ol>

        <h2 id="development"><span class="emoji">🛠️</span> Development Workflow</h2>
        
        <h3>Adding New Flows</h3>
        <ol>
            <li><strong>Create Python file</strong> with Prefect flow:
                <pre><code>from prefect import flow, task

@task
def my_task():
    return "Hello World"

@flow(name="My New Flow")
def my_flow():
    result = my_task()
    return result</code></pre>
            </li>
            <li><strong>Add to auto-deploy script:</strong>
                <pre><code># In auto_deploy_flows.py
flows_to_deploy.append({
    'module': 'my_new_flow',
    'flow_name': 'my_flow',
    'deployment_name': 'my-new-flow'
})</code></pre>
            </li>
            <li><strong>Push to GitHub</strong> - Auto-deployment will handle the rest</li>
        </ol>

        <h3>Testing Flows</h3>
        <ol>
            <li><strong>Test locally:</strong>
                <pre><code>python my_flow.py</code></pre>
            </li>
            <li><strong>Test in Prefect:</strong>
                <pre><code>prefect flow run my_flow</code></pre>
            </li>
            <li><strong>Test deployment:</strong>
                <ul>
                    <li>Run from Prefect UI</li>
                    <li>Check logs and results</li>
                </ul>
            </li>
        </ol>

        <h2 id="auto-deploy-script"><span class="emoji">🤖</span> Auto-Deploy Script Details</h2>
        
        <h3>Script: auto_deploy_flows.py</h3>
        <p>This script automatically discovers and deploys all Prefect flows in the directory every 2 minutes.</p>
        
        <pre><code>#!/usr/bin/env python3
"""
Simple Auto-Deploy Script for Prefect Flows
Automatically deploys all known Prefect flows in the directory.
"""

import os
import sys
from datetime import datetime

# Add the current directory to Python path
sys.path.insert(0, '/home/ubuntu/WorkFlow-TestRig')

def auto_deploy_flows():
    """Auto-deploy all known flows"""
    print(f"🔍 Auto-Deploy Started at {datetime.now()}")
    print("=" * 50)
    
    flows_deployed = 0
    
    # List of known flows to deploy
    flows_to_deploy = [
        {
            'module': 'CloudFlare_Stats_To_Slack_Prefect',
            'flow_name': 'cloudflare_stats_flow',
            'deployment_name': 'cloudflare-stats-flow'
        },
        {
            'module': 'zstd_to_csv_converter_prefect', 
            'flow_name': 'zstd_to_csv_converter_flow',
            'deployment_name': 'zstd-to-csv-converter-flow'
        }
    ]
    
    for flow_info in flows_to_deploy:
        try:
            print(f"\n📄 Processing: {flow_info['module']}")
            
            # Import the module
            module = __import__(flow_info['module'])
            flow_func = getattr(module, flow_info['flow_name'])
            
            print(f"✅ Found flow: {flow_func.name}")
            
            # Create deployment
            deployment = flow_func.to_deployment(
                name=flow_info['deployment_name'],
                work_pool_name='default-pool'
            )
            
            print(f"🚀 Deployed: {flow_info['deployment_name']}")
            flows_deployed += 1
            
        except Exception as e:
            print(f"❌ Error deploying {flow_info['module']}: {e}")
            continue
    
    print(f"\n🎉 Auto-Deploy Complete!")
    print(f"✅ Successfully deployed: {flows_deployed}/{len(flows_to_deploy)} flows")
    print(f"⏰ Next run in 2 minutes...")

if __name__ == "__main__":
    auto_deploy_flows()</code></pre>

        <h3>Monitoring Script: check_auto_deploy.py</h3>
        <p>This script monitors the auto-deployment system and shows status information.</p>
        
        <pre><code>#!/usr/bin/env python3
"""
Monitor Auto-Deploy Script
Shows the status of automatic deployments
"""

import os
from datetime import datetime

def check_auto_deploy_status():
    """Check the status of auto-deployment"""
    print("🔍 Auto-Deploy Status Check")
    print("=" * 40)
    
    log_file = "/home/ubuntu/auto_deploy.log"
    
    if os.path.exists(log_file):
        print(f"📄 Log file exists: {log_file}")
        
        # Get file size and modification time
        stat = os.stat(log_file)
        size = stat.st_size
        mtime = datetime.fromtimestamp(stat.st_mtime)
        
        print(f"📏 Log file size: {size} bytes")
        print(f"⏰ Last modified: {mtime}")
        
        # Show last few lines
        print(f"\n📋 Last 10 lines of log:")
        print("-" * 40)
        
        try:
            with open(log_file, 'r') as f:
                lines = f.readlines()
                for line in lines[-10:]:
                    print(line.strip())
        except Exception as e:
            print(f"❌ Error reading log: {e}")
    else:
        print(f"❌ Log file not found: {log_file}")
        print("💡 The cron job hasn't run yet or there's an issue")
    
    print(f"\n⏰ Current time: {datetime.now()}")
    print("🔄 Next auto-deploy should run within 2 minutes...")

if __name__ == "__main__":
    check_auto_deploy_status()</code></pre>

        <h3>Cron Job Setup</h3>
        <p>To set up automatic deployment every 2 minutes:</p>
        
        <pre><code># Add to crontab
*/2 * * * * cd /home/ubuntu/WorkFlow-TestRig && source /home/ubuntu/.venv/prefect/bin/activate && python auto_deploy_flows.py >> /home/ubuntu/auto_deploy.log 2>&1</code></pre>

        <h2 id="prefect-yaml"><span class="emoji">⚙️</span> Prefect Configuration</h2>
        
        <h3>prefect.yaml Configuration</h3>
        <p>This file defines deployment configurations for all flows:</p>
        
        <pre><code># Welcome to your prefect.yaml file! You can use this file for storing and managing
# configuration for deploying your flows. We recommend committing this file to source
# control along with your flow code.

# Generic metadata about this project
name: WorkFlow-TestRig
prefect-version: 3.4.11

# build section allows you to manage and build docker images
build: null

# push section allows you to manage if and how this project is uploaded to remote locations
push: null

# pull section allows you to provide instructions for cloning this project in remote locations
pull:
- prefect.deployments.steps.set_working_directory:
    directory: /home/ubuntu/WorkFlow-TestRig

# the deployments section allows you to provide configuration for deploying flows
deployments:
# CloudFlare Stats Flow Deployment
- name: cloudflare-stats-deployment
  version: 1.0.0
  tags: [cloudflare, slack, monitoring]
  description: "CloudFlare statistics to Slack notification flow"
  schedule: {}
  flow_name: Cloudflare Stats Flow
  entrypoint: CloudFlare_Stats_To_Slack_Prefect.py:cloudflare_stats_flow
  parameters: {}
  work_pool:
    name: default-pool
    work_queue_name: null
    job_variables: {}

# ZSTD to CSV Converter Deployment  
- name: zstd-to-csv-converter-deployment
  version: 1.0.0
  tags: [zstd, csv, data-processing]
  description: "Convert ZSTD compressed files to CSV format"
  schedule: {}
  flow_name: ZSTD to CSV Converter Flow
  entrypoint: zstd_to_csv_converter_prefect.py:zstd_to_csv_converter_flow
  parameters: {}
  work_pool:
    name: default-pool
    work_queue_name: null
    job_variables: {}</code></pre>

        <h2 id="requirements"><span class="emoji">📦</span> Dependencies</h2>
        
        <h3>requirement.txt</h3>
        <pre><code>prefect>=3.0.0
requests>=2.28.0
zstandard>=0.21.0</code></pre>

        <h2 id="flow-examples"><span class="emoji">💻</span> Complete Flow Examples</h2>
        
        <h3>CloudFlare Stats Flow</h3>
        <pre><code>import requests
from datetime import datetime, timedelta
from prefect import flow, task
from prefect.blocks.system import Secret

# Configuration - Using Prefect Secret Blocks
SLACK_CHANNEL_ID = "C079Z48QE49"

RED_COLOR = "#ff0000"
YELLOW_COLOR = "#F7DC6F"
GREEN_COLOR = "#229954"

@task
def get_yesterday_date():
    today = datetime.utcnow().date()
    return today - timedelta(days=1)

@task
async def get_account_id(api_token):
    url = "https://api.cloudflare.com/client/v4/accounts"
    headers = {"Authorization": f"Bearer {api_token}", "Content-Type": "application/json"}
    response = requests.get(url, headers=headers)
    if response.status_code != 200: 
        return None
    data = response.json()
    if not data["success"] or not data["result"]: 
        return None
    return data["result"][0]["id"]

@task
async def get_aggregated_metrics(date, account_id, api_token):
    url = "https://api.cloudflare.com/client/v4/graphql"
    headers = {"Content-Type": "application/json", "Authorization": f"Bearer {api_token}"}
    query = """
    {
      viewer {
        accounts(filter: {accountTag: "%s"}) {
          httpRequests1dGroups(limit: 1, filter: {date: "%s"}) {
            dimensions { date }
            sum {
              requests
              bytes
              cachedBytes
              cachedRequests
              responseStatusMap { edgeResponseStatus requests }
            }
          }
        }
      }
    }""" % (account_id, date)
    response = requests.post(url, headers=headers, json={"query": query})
    return response.json() if response.status_code == 200 else None

@task
def process_account_data(metrics_data):
    if not metrics_data or "data" not in metrics_data: return None
    viewer = metrics_data["data"].get("viewer", {})
    accounts = viewer.get("accounts", [])
    totals = {"total_requests":0, "total_cached_requests":0, "total_bytes":0, "total_cached_bytes":0, "total_4xx":0, "total_5xx":0}

    for account in accounts:
        http_group = account.get("httpRequests1dGroups", [{}])[0]
        stats = http_group.get("sum", {})
        totals["total_requests"] += stats.get("requests",0)
        totals["total_cached_requests"] += stats.get("cachedRequests",0)
        totals["total_bytes"] += stats.get("bytes",0)
        totals["total_cached_bytes"] += stats.get("cachedBytes",0)

        for status in stats.get("responseStatusMap", []):
            try:
                code = int(status["edgeResponseStatus"])
                count = status["requests"]
                if 400 <= code < 500: totals["total_4xx"] += count
                elif 500 <= code < 600: totals["total_5xx"] += count
            except ValueError: continue
    return totals

@task
def get_hit_ratio_color(hit_ratio):
    if hit_ratio < 90: return RED_COLOR
    elif hit_ratio < 95: return YELLOW_COLOR
    else: return GREEN_COLOR

@task
async def send_to_slack(target_date, hit_ratio, cache_coverage, total_requests, origin_fetches, bandwidth, status_4xx, status_5xx, slack_bot_token):
    color = get_hit_ratio_color(hit_ratio)
    text = (
        f"*Avg Hit Ratio: {hit_ratio:.2f}%*\n"
        f"*Avg Cache Coverage: {cache_coverage:.2f}%*\n"
        f"*CDN Requests: {total_requests}*\n"
        f"*CDN Origin Fetches: {origin_fetches}*\n"
        f"*CDN Bandwidth: {bandwidth}*\n"
        f"*CDN Status 4xx Requests: {status_4xx}*\n"
        f"*CDN Status 5xx Requests: {status_5xx}*"
    )
    payload = {"channel": SLACK_CHANNEL_ID, "text": f"Cloudflare Stats *{target_date}*", "attachments":[{"fallback":"Cloudflare Performance Stats","color":color,"text":text}]}
    response = requests.post("https://slack.com/api/chat.postMessage", headers={"Content-Type":"application/json","Authorization":f"Bearer {slack_bot_token}"}, json=payload)
    return response.status_code == 200

@flow(name="Cloudflare Stats Flow")
async def cloudflare_stats_flow():
    # Load tokens from Prefect Secret Blocks
    cloudflare_token_block = await Secret.load("cloudflare-api-token")
    slack_token_block = await Secret.load("slack-bot-token")
    
    api_token = cloudflare_token_block.get()
    slack_bot_token = slack_token_block.get()
    
    print(f"🔐 Loaded CloudFlare API token: {api_token[:10]}...")
    print(f"🔐 Loaded Slack Bot token: {slack_bot_token[:10]}...")
    
    yesterday = get_yesterday_date()
    formatted_yesterday = yesterday.strftime("%Y-%m-%d")
    account_id = await get_account_id(api_token)
    if not account_id: return
    
    metrics = await get_aggregated_metrics(formatted_yesterday, account_id, api_token)
    stats = process_account_data(metrics)
    if not stats: return

    origin_fetches = stats["total_requests"] - stats["total_cached_requests"]
    hit_ratio = (stats["total_cached_requests"] / stats["total_requests"] * 100) if stats["total_requests"]>0 else 0
    cache_coverage = (stats["total_cached_bytes"] / stats["total_bytes"] * 100) if stats["total_bytes"]>0 else 0
    bandwidth = f"{stats['total_bytes']/(1024**4):.2f} TiB"

    await send_to_slack(formatted_yesterday, hit_ratio, cache_coverage, stats["total_requests"], origin_fetches, bandwidth, stats["total_4xx"], stats["total_5xx"], slack_bot_token)

if __name__ == "__main__":
    import asyncio
    asyncio.run(cloudflare_stats_flow())</code></pre>

        <h3>ZSTD to CSV Converter Flow</h3>
        <pre><code>#!/usr/bin/env python3

import os
import json
import csv
import zstandard as zstd
from prefect import flow, task
from datetime import datetime

@task
def decompress_zstd_file(input_file, output_file):
    """Decompress zstd file to JSON"""
    print(f"📦 Starting decompression of {input_file}...")
    print(f"📏 Input file size: {os.path.getsize(input_file):,} bytes")
    
    with open(input_file, 'rb') as compressed_file:
        dctx = zstd.ZstdDecompressor()
        with open(output_file, 'wb') as decompressed_file:
            dctx.copy_stream(compressed_file, decompressed_file)
    
    print(f"✅ Decompression complete. File saved as {output_file}")
    print(f"📏 Output file size: {os.path.getsize(output_file):,} bytes")
    return output_file

@task
def convert_json_to_csv(input_file, output_file_base, rows_per_file):
    """Convert JSON to CSV files"""
    print(f"🔄 Starting conversion of {input_file} to CSV...")
    print(f"📊 Target: {rows_per_file:,} rows per CSV file")
    
    headers = ['timestamp', 'geo_city', 'response_status', 'org', 'apiKey', 'shield', 'cache', 'host', 'pop', 'resTime', 'response_body_size', 'request_user_agent', 'response_body_size', 'url'] 
    file_count = 1
    row_count = 0
    total_lines_processed = 0

    with open(input_file, 'r') as json_file:
        csv_file = open(f"{output_file_base}_{file_count}.csv", 'w', newline='')
        writer = csv.DictWriter(csv_file, fieldnames=headers)
        writer.writeheader()

        for line_num, line in enumerate(json_file, 1):
            if line.strip():
                try:
                    data = json.loads(line)
                    row = {key: data.get(key, '') for key in headers}
                    writer.writerow(row)
                    row_count += 1
                    total_lines_processed += 1

                    # Progress logging every 10,000 lines
                    if line_num % 10000 == 0:
                        print(f"📈 Processed {line_num:,} lines, {row_count:,} rows in current file")

                    if row_count >= rows_per_file:
                        csv_file.close()
                        print(f"✅ Completed CSV file {file_count} with {row_count:,} rows")
                        file_count += 1
                        row_count = 0
                        csv_file = open(f"{output_file_base}_{file_count}.csv", 'w', newline='')
                        writer = csv.DictWriter(csv_file, fieldnames=headers)
                        writer.writeheader()

                except json.JSONDecodeError as e:
                    print(f"⚠️  Error parsing line {line_num}: {e}")
                    continue

        csv_file.close()

    print(f"🎉 Conversion complete! Created {file_count} CSV files")
    print(f"📊 Total lines processed: {total_lines_processed:,}")
    print(f"📁 Files saved as: {output_file_base}_1.csv, {output_file_base}_2.csv, etc.")
    return file_count

@task
def cleanup_temp_file(file_path):
    """Clean up temporary JSON file"""
    if os.path.exists(file_path):
        file_size = os.path.getsize(file_path)
        os.remove(file_path)
        print(f"🗑️  Cleaned up temporary file: {file_path}")
        print(f"📏 Freed up {file_size:,} bytes of disk space")
    return True

@flow(name="ZSTD to CSV Converter Flow")
def zstd_to_csv_converter_flow():
    """Main flow to convert zstd file to CSV"""
    print("🚀 Starting ZSTD to CSV conversion process...")

    # File paths
    input_zstd = '/home/ubuntu/Files/Input.zstd'
    output_json = '/home/ubuntu/Output files/temp_conversion.json'
    output_csv_base = '/home/ubuntu/Output files/converted_data'
    rows_per_file = 1000000

    # Create output directory if it doesn't exist
    os.makedirs('/home/ubuntu/Output files', exist_ok=True)

    print(f"📂 Input file: {input_zstd}")
    print(f"📄 Output JSON: {output_json}")
    print(f"📊 Output CSV base: {output_csv_base}")
    print(f"📈 Rows per CSV file: {rows_per_file:,}")

    # Check if input file exists
    if not os.path.exists(input_zstd):
        print(f"❌ Error: Input file {input_zstd} not found!")
        return

    print(f"✅ Input file found! Size: {os.path.getsize(input_zstd):,} bytes")

    # Step 1: Decompress the zstd file
    print("\n🔄 STEP 1: Decompressing ZSTD file...")
    decompressed_file = decompress_zstd_file(input_zstd, output_json)

    # Step 2: Check if the decompressed file exists
    if not os.path.exists(output_json):
        print(f"❌ Error: Decompressed file {output_json} not found.")
        return

    print(f"✅ Decompression successful!")

    # Step 3: Convert the decompressed JSON to CSV
    print("\n🔄 STEP 2: Converting JSON to CSV files...")
    csv_file_count = convert_json_to_csv(output_json, output_csv_base, rows_per_file)

    # Step 4: Clean up temporary JSON file
    print("\n🔄 STEP 3: Cleaning up temporary files...")
    cleanup_temp_file(output_json)

    print(f"✅ Conversion completed successfully!")
    print(f"📁 Created {csv_file_count} CSV files in /home/ubuntu/Output files/")
    print(f"📊 Each file contains up to {rows_per_file:,} rows")
    print(f"🎯 Output directory: /home/ubuntu/Output files/")

    return {
        "status": "success",
        "csv_files_created": csv_file_count,
        "rows_per_file": rows_per_file,
        "output_directory": "/home/ubuntu/Output files/"
    }

if __name__ == "__main__":
    result = zstd_to_csv_converter_flow()
    print(f"Final result: {result}")</code></pre>

        <div class="footer">
            <p><strong>Last Updated:</strong> October 2024 | <strong>Version:</strong> 1.0.0 | <strong>Prefect Version:</strong> 3.x</p>
            <p>This document provides a comprehensive guide to setting up and managing Prefect workflow orchestration with automatic deployment capabilities.</p>
        </div>
    </div>
</body>
</html>
